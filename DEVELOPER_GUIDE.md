# Enable Micro Frontend Architecture (MFA) in Any Repo

A step-by-step developer guide for enabling **Module Federation** in any existing Vite + React + TypeScript project using [`@module-federation/vite`](https://github.com/module-federation/vite).

---

## Table of Contents

- [Prerequisites](#prerequisites)
- [Architecture Overview](#architecture-overview)
- [Quick Start (Automated)](#quick-start-automated)
- [CI / GitHub Actions](#ci--github-actions)
- [Manual Setup: Remote App](#manual-setup-remote-app)
- [Manual Setup: Host App](#manual-setup-host-app)
- [Tailwind CSS v4 Cross-MFE Styling](#tailwind-css-v4-cross-mfe-styling)
- [TypeScript Type Declarations](#typescript-type-declarations)
- [Consuming Remote Components](#consuming-remote-components)
- [Exposing New Components](#exposing-new-components)
- [Adding a New Remote App](#adding-a-new-remote-app)
- [Production Deployment](#production-deployment)
- [Configuration Reference](#configuration-reference)
- [The `.__mf__temp` Directory](#the-__mf__temp-directory)
- [Troubleshooting](#troubleshooting)
- [Quick Reference](#quick-reference)
- [Reference Project Structure](#reference-project-structure)
- [Further Reading](#further-reading)

---

## Prerequisites

| Requirement            | Minimum Version |
| ---------------------- | --------------- |
| Node.js                | 18+             |
| Vite                   | 6.x / 7.x      |
| React                  | 18.x / 19.x    |
| TypeScript             | 5.x             |
| Package manager        | pnpm / npm / yarn / bun |

> **Note:** This guide uses `pnpm` in examples. Replace with your package manager of choice.

---

## Architecture Overview

Module Federation allows multiple independently-built applications to share code at **runtime**. No monorepo or shared build pipeline is required — apps communicate over HTTP.

```
┌──────────────────────────────────────────────────────────────┐
│                      HOST APP (:5000)                        │
│                                                              │
│   import("remote/components")  ───── HTTP at runtime ──────┐ │
│                                                              │ │
│   Uses React.lazy + Suspense to render remote components     │ │
└──────────────────────────────────────────────────────────────┘ │
                                                                 │
                                                                 ▼
┌──────────────────────────────────────────────────────────────┐
│                     REMOTE APP (:5001)                        │
│                                                              │
│   Exposes:  "./components" → src/components/index.ts         │
│   Serves:   remoteEntry.js (federation manifest)             │
│                                                              │
│   Also runs standalone as its own independent app            │
└──────────────────────────────────────────────────────────────┘
```

**Key concepts:**

- **Remote** — an app that **exposes** modules (components, utils, etc.) for other apps to consume
- **Host** — an app that **consumes** modules from one or more remotes
- **Shared dependencies** — libraries like `react` and `react-dom` marked as `singleton: true` so only one instance runs across all federated apps
- **`remoteEntry.js`** — the manifest file generated by Module Federation that the host fetches at runtime

---

## Quick Start (Automated)

Use the `mfx` CLI wizard (located in `tools/mfx/`). Just run it and answer the questions — like `create-vite` or `shadcn init`.

### Install & Build

```bash
cd tools/mfx
pnpm install
pnpm build
```

### Usage

```bash
# Interactive wizard — walks you through everything
node tools/mfx/dist/cli.js

# Or run with tsx during development
pnpm --filter mfx dev

# Preview without writing (dry run)
node tools/mfx/dist/cli.js --dry-run
```

Flags are optional shortcuts — they pre-fill answers so the wizard skips those questions:

```bash
# Pre-fill project dir and role (wizard still asks for name, port, etc.)
node tools/mfx/dist/cli.js -d ./my-remote -r remote

# Fully non-interactive (all defaults, auto-confirm)
node tools/mfx/dist/cli.js \
  -d ./my-remote \
  -r remote \
  -n myRemote \
  -p 5001 \
  -y
```

### CLI Options

All flags are optional. If omitted, the wizard will ask interactively.

| Flag                  | Description                                    |
| --------------------- | ---------------------------------------------- |
| `-d, --project-dir`   | Skip the "project path" question               |
| `-r, --role`          | Skip the "role" question (`remote` or `host`)  |
| `-n, --name`          | Skip the "federation name" question            |
| `-p, --port`          | Skip the "port" question                       |
| `-y, --yes`           | Auto-confirm all prompts (use defaults)        |
| `--dry-run`           | Preview generated files without writing        |
| `--no-install`        | Skip dependency installation (CI / air-gapped) |
| `--build-target`      | Vite build target (`chrome89` \| `esnext` \| `es2022` \| `es2021` \| `es2020`) |
| `-c, --config <path>` | Path to config file (auto-detected by default) |
| `--verbose`           | Show detailed output                           |
| `--quiet`             | Suppress non-essential output                  |
| `-h, --help`          | Show help                                      |
| `-V, --version`       | Show version                                   |

### Config File (optional)

You can pre-fill wizard answers by placing an `mfa.config.json` (or `.mfarc.json`) in your project root. The wizard auto-detects it — no flags needed.

**Priority order:** CLI flags > config file > interactive prompt

#### JSON Schema (IDE autocompletion)

Add a `$schema` property at the top of your config file for inline validation and autocompletion in VS Code, WebStorm, etc.:

```json
{
  "$schema": "./node_modules/mfx/mfa.config.schema.json"
}
```

The schema is automatically included when you generate a config via `mfx config`.

#### Remote example

```json
{
  "$schema": "./node_modules/mfx/mfa.config.schema.json",
  "role": "remote",
  "name": "sharedUI",
  "port": "5002",
  "buildTarget": "chrome89",
  "exposes": {
    "./components": "./src/components/index.ts",
    "./hooks": "./src/hooks/index.ts"
  }
}
```

#### Host example

```json
{
  "role": "host",
  "name": "shell",
  "port": "5000",
  "remotes": {
    "sharedUI": {
      "entry": "http://localhost:5002/remoteEntry.js",
      "types": {
        "./components": ["Button", "Card", "Dialog"],
        "./hooks": ["useTheme", "useAuth"]
      },
      "tailwindSource": "../../mfa-remote/src"
    }
  }
}
```

#### Config in package.json

Instead of a separate file, you can add a `"mfx"` key in your `package.json`:

```json
{
  "name": "my-app",
  "mfx": {
    "role": "remote",
    "name": "myApp",
    "port": "5001"
  }
}
```

#### Config detection order

1. `--config <path>` flag (explicit path)
2. `mfa.config.json` in project root
3. `.mfarc.json` in project root
4. `"mfx"` key in `package.json`

#### Supported fields

| Field             | Type                              | Description                                     |
| ----------------- | --------------------------------- | ----------------------------------------------- |
| `$schema`         | `string`                          | JSON Schema path for IDE autocompletion          |
| `$version`        | `number`                          | Schema version for future migrations (default 1) |
| `role`            | `"remote"` or `"host"`           | App role in the federation                      |
| `name`            | `string`                          | Unique federation name                          |
| `port`            | `string` or `number`             | Dev server port (normalised to string at load)  |
| `buildTarget`     | `string`                          | Vite `build.target` — defaults to `"chrome89"`  |
| `exposes`         | `Record<string, string>`          | *(Remote only)* Module path → local file        |
| `remotes`         | `Record<string, RemoteEntry>`     | *(Host only)* Remote name → config object       |
| `remotes.*.entry` | `string`                          | URL to the remote's `remoteEntry.js`            |
| `remotes.*.types` | `Record<string, string[]>`        | Module path → exported component names          |
| `remotes.*.tailwindSource` | `string`                 | Relative path to remote's src/ for `@source`    |
| `shared`          | `Record<string, SharedDep\|bool>` | Additional shared deps beyond react defaults    |

### What the wizard does

1. **Step 1** — Asks where your project is (or auto-detects from `--project-dir`)
2. **Step 2** — Asks whether the app is a **host** or **remote**
3. **Step 3** — Asks for the federation name
4. **Step 4** — Asks for the dev server port
5. **Step 5** — Collects exposed modules (remote) or remote app details (host)
6. **Step 6** — Shows a full preview, then applies changes on confirmation
7. Installs `@module-federation/vite`
8. Updates `.gitignore`

### Additional commands

After initial setup, use these commands to manage your federation config:

```bash
# Add/update/remove exposed modules (remote apps)
node tools/mfx/dist/cli.js expose -d ./my-remote

# Add/update/remove remote applications (host apps)
node tools/mfx/dist/cli.js remote -d ./my-host

# Create or edit mfa.config.json interactively
node tools/mfx/dist/cli.js config -d ./my-app

# Validate your setup — check deps, files, config health
node tools/mfx/dist/cli.js doctor -d ./my-app

# Clean reverse of init — remove federation from a project
node tools/mfx/dist/cli.js remove -d ./my-app

# Show current federation config at a glance (read-only)
node tools/mfx/dist/cli.js status -d ./my-app

# JSON output for scripting / CI
node tools/mfx/dist/cli.js status -d ./my-app --json

# Set up multiple apps in a monorepo (batch mode)
node tools/mfx/dist/cli.js workspace -w ./monorepo

# Open web-based GUI for visual configuration
node tools/mfx/dist/cli.js gui

# Or use the --gui flag on init
node tools/mfx/dist/cli.js init --gui
```

The `config` command lets you interactively edit your `mfa.config.json` and optionally re-apply the changes immediately. If no config file exists, it infers current settings from your `vite.config.ts`.

The `doctor` command validates your setup by checking: `package.json`, Vite config, installed dependencies, federation configuration, exposed files, remote URLs, type declarations, `.gitignore`, and more. Results are shown as pass/warn/fail.

The `remove` command is a clean reverse of `init` — it removes the `federation()` plugin from `vite.config.ts`, deletes generated `.d.ts` files, optionally removes config files and the `.__mf__temp` directory, and offers to uninstall `@module-federation/vite`.

The `status` command prints a read-only summary of the current project's Module Federation configuration (role, name, port, exposes/remotes, dependencies). Use `--json` for machine-readable output in CI.

The `workspace` command sets up Module Federation in multiple apps at once. It reads `mfa.workspace.json` or auto-discovers Vite projects in `apps/`, `packages/`, etc. Each app is configured sequentially with `--yes` mode. Ideal for monorepos.

The `gui` command starts a lightweight local HTTP server and opens a modern web UI in your browser. You can configure everything visually — detect projects, pick a role, set federation name and port, manage exposes/remotes, and apply with one click. Useful for developers who prefer a visual form over a CLI wizard. Use `--no-open` to prevent auto-opening the browser, or `-p <port>` to specify a server port.

### CI / GitHub Actions

The CLI supports fully non-interactive execution for CI pipelines:

```yaml
# .github/workflows/mfx.yml
name: Setup Module Federation

on:
  workflow_dispatch:
    inputs:
      role:
        description: "App role"
        required: true
        type: choice
        options:
          - remote
          - host

jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 10

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install mfx
        run: |
          cd tools/mfx
          pnpm install
          pnpm build

      - name: Run mfx
        run: |
          node tools/mfx/dist/cli.js init \
            -d . \
            -r ${{ github.event.inputs.role }} \
            -n myApp \
            -p 5001 \
            -y \
            --no-install \
            --quiet

      - name: Validate setup
        run: node tools/mfx/dist/cli.js doctor -d .

      - name: Commit changes
        run: |
          git add -A
          git diff --cached --quiet || git commit -m "chore: enable Module Federation (${{ github.event.inputs.role }})"
```

#### Monorepo CI

For monorepos, use the `workspace` command with a checked-in `mfa.workspace.json`:

```yaml
      - name: Setup all MFA apps
        run: |
          node tools/mfx/dist/cli.js workspace \
            -w . \
            -y \
            --no-install \
            --quiet
```

#### Key flags for CI

| Flag | Purpose |
| --- | --- |
| `-y, --yes` | Skip all interactive prompts |
| `--no-install` | Skip `npm install` (CI handles deps separately) |
| `--quiet` | Suppress decorative output for clean logs |
| `--dry-run` | Preview changes without writing (for PR checks) |
| `--json` | Machine-readable output (`status --json`) |

---

## Manual Setup: Remote App

A **remote** app exposes components that other apps can import at runtime.

### Step 1 — Install the federation plugin

```bash
pnpm add -D @module-federation/vite
```

### Step 2 — Create a barrel file for exposed components

```ts
// src/components/index.ts
export { MyButton } from "./my-button"
export { MyCard } from "./my-card"
```

### Step 3 — Configure `vite.config.ts`

```ts
import path from "path"
import tailwindcss from "@tailwindcss/vite"       // Only if using Tailwind CSS v4
import react from "@vitejs/plugin-react"
import { federation } from "@module-federation/vite"
import { defineConfig } from "vite"

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),                                  // Only if using Tailwind CSS v4
    federation({
      name: "remote",                               // Unique name — must match host config
      filename: "remoteEntry.js",                   // Entry file the host fetches
      dts: false,                                   // Disable auto type generation (see note below)
      exposes: {
        // Key   = public import path (host imports as "remote/components")
        // Value = local file path to the barrel/entry file
        "./components": "./src/components/index.ts",
      },
      shared: {
        // Singleton prevents duplicate React instances across host + remote
        react: { singleton: true },
        "react-dom": { singleton: true },
        "react/": { singleton: true },              // Sub-path imports
        "react-dom/": { singleton: true },
      },
    }),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 5001,                                     // Fixed port — host depends on this
    strictPort: true,                               // Fail if port is taken
    origin: "http://localhost:5001",                 // CRITICAL: assets served with absolute URLs
                                                    // so the host can resolve JS/CSS chunks
  },
  build: {
    target: "chrome89",                             // Required for top-level await in federation
  },
})
```

### Step 4 — Update `.gitignore`

```
# Module Federation temp files
.__mf__temp
```

### Step 5 — Start the remote

```bash
pnpm dev
```

Verify `http://localhost:5001/remoteEntry.js` is accessible in the browser.

---

## Manual Setup: Host App

A **host** app consumes components from one or more remote apps.

### Step 1 — Install the federation plugin

```bash
pnpm add -D @module-federation/vite
```

### Step 2 — Configure `vite.config.ts`

```ts
import path from "path"
import tailwindcss from "@tailwindcss/vite"       // Only if using Tailwind CSS v4
import react from "@vitejs/plugin-react"
import { federation } from "@module-federation/vite"
import { defineConfig } from "vite"

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),                                  // Only if using Tailwind CSS v4
    federation({
      name: "host",                                 // Unique name for this host
      remotes: {
        // Each key becomes the import prefix: import("remote/components")
        remote: {
          type: "module",                           // ESM format (Vite default)
          name: "remote",                           // Must match remote's federation name
          entry: "http://localhost:5001/remoteEntry.js",  // URL to remote's entry file
          entryGlobalName: "remote",                // Global variable name
          shareScope: "default",                    // Shared dependency scope
        },
      },
      filename: "remoteEntry.js",                   // Host can also be consumed (optional)
      dts: false,                                   // Disable auto type generation
      shared: {
        // Must match the remote's shared config
        react: { singleton: true },
        "react-dom": { singleton: true },
        "react/": { singleton: true },
        "react-dom/": { singleton: true },
      },
    }),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 5000,                                     // Host port
    strictPort: true,
  },
  build: {
    target: "chrome89",                             // Required for top-level await
  },
})
```

### Step 3 — Create type declarations for the remote

```ts
// src/remote.d.ts
declare module "remote/components" {
  import type { FC } from "react"
  export const MyButton: FC
  export const MyCard: FC
}
```

This gives TypeScript full type safety for remote imports without needing the remote's actual types.

### Step 4 — Update `.gitignore`

```
# Module Federation temp files
.__mf__temp
```

### Step 5 — Start both apps

**Always start the remote first**, then the host:

```bash
# Terminal 1 — Remote must be running first
cd my-remote && pnpm dev

# Terminal 2 — Host
cd my-host && pnpm dev
```

---

## Tailwind CSS v4 Cross-MFE Styling

### The Problem

Tailwind CSS v4 only generates CSS for utility classes it finds in **scanned** source files. When the host loads remote components at runtime, those components use Tailwind classes that Tailwind never saw during the host's build — resulting in **unstyled components**.

### The Solution

In the **host's** `src/index.css`, use the `@source` directive to scan the remote's source files:

```css
@import "tailwindcss";
@import "tw-animate-css";
@import "shadcn/tailwind.css";

/* Scan remote app source files so Tailwind includes their utility classes */
@source "../../my-remote/src";
```

This tells Tailwind v4 to scan the remote's `src/` directory for class names and include them in the host's CSS output.

> **Requirement:** Both projects must be accessible on the filesystem (e.g., same monorepo or sibling directories).

### shadcn/ui Theme Inheritance

If both apps use shadcn/ui, the host defines CSS custom properties (`:root`, `.dark`) in its `index.css`. Remote components rendered inside the host automatically inherit the host's theme variables — no extra config needed.

---

## TypeScript Type Declarations

### Why `dts: false`?

The `@module-federation/vite` plugin includes a DTS feature that auto-generates type declarations by downloading a `@mf-types.zip` from the remote. However, this causes issues:

1. **Startup order dependency** — the remote must be running when the host starts
2. **`rootDir` error** — fails with project-references-style `tsconfig.json` (`"files": []`)

Setting `dts: false` and writing manual `.d.ts` files is simpler and more reliable.

### Manual Type Declarations

Create a `.d.ts` file in the host's `src/` directory for each remote:

```ts
// src/remote.d.ts
declare module "remote/components" {
  import type { FC } from "react"
  export const MyButton: FC
  export const MyCard: FC
}

// If exposing multiple paths:
declare module "remote/utils" {
  export function formatDate(date: Date): string
  export function capitalize(str: string): string
}
```

The `tsconfig.app.json` with `"include": ["src"]` automatically picks up these declarations.

---

## Consuming Remote Components

Use `React.lazy` + `Suspense` for async loading of federated modules:

```tsx
import { Suspense, lazy } from "react"

// Lazy-load remote components
const RemoteComponents = lazy(async () => {
  const { MyButton, MyCard } = await import("remote/components")
  return {
    default: () => (
      <>
        <MyCard />
        <MyButton />
      </>
    ),
  }
})

export function App() {
  return (
    <div>
      <h1>My Host App</h1>
      <Suspense fallback={<div>Loading remote components...</div>}>
        <RemoteComponents />
      </Suspense>
    </div>
  )
}
```

### Why `React.lazy` with a wrapper?

`React.lazy` expects a module with a `default` export. Since federated modules typically use named exports, we wrap them in a factory that returns `{ default: Component }`.

---

## Exposing New Components

To add a new component to an existing remote:

### 1. Create the component

```tsx
// my-remote/src/components/my-widget.tsx
export function MyWidget() {
  return <div className="p-4 border rounded-lg">My Widget</div>
}
```

### 2. Export from the barrel file

```ts
// my-remote/src/components/index.ts
export { MyButton } from "./my-button"
export { MyCard } from "./my-card"
export { MyWidget } from "./my-widget"    // ← Add this
```

No changes to `vite.config.ts` needed — `"./components"` already points to `index.ts`.

### 3. Add the type declaration in the host

```ts
// my-host/src/remote.d.ts
declare module "remote/components" {
  import type { FC } from "react"
  export const MyButton: FC
  export const MyCard: FC
  export const MyWidget: FC               // ← Add this
}
```

### 4. Use it in the host

```tsx
const { MyWidget } = await import("remote/components")
```

### 5. Restart both dev servers

Federation config changes require a restart.

---

## Adding a New Remote App

### Step 1 — Scaffold the new remote

```bash
pnpm create vite my-new-remote --template react-ts
cd my-new-remote
pnpm add -D @module-federation/vite
```

### Step 2 — Configure `vite.config.ts` (complete)

```ts
import path from "path"
import tailwindcss from "@tailwindcss/vite"       // If using Tailwind
import react from "@vitejs/plugin-react"
import { federation } from "@module-federation/vite"
import { defineConfig } from "vite"

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),                                  // If using Tailwind
    federation({
      name: "newRemote",                            // Must be unique across all remotes
      filename: "remoteEntry.js",
      dts: false,
      exposes: {
        "./feature": "./src/feature/index.ts",
      },
      shared: {
        react: { singleton: true },
        "react-dom": { singleton: true },
        "react/": { singleton: true },
        "react-dom/": { singleton: true },
      },
    }),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 5002,                                     // Unique port
    strictPort: true,
    origin: "http://localhost:5002",
  },
  build: {
    target: "chrome89",
  },
})
```

### Step 3 — Register in the host's `vite.config.ts`

Add the new remote to the `remotes` object:

```ts
federation({
  name: "host",
  remotes: {
    remote: {
      type: "module",
      name: "remote",
      entry: "http://localhost:5001/remoteEntry.js",
      entryGlobalName: "remote",
      shareScope: "default",
    },
    newRemote: {                                    // ← Add this
      type: "module",
      name: "newRemote",
      entry: "http://localhost:5002/remoteEntry.js",
      entryGlobalName: "newRemote",
      shareScope: "default",
    },
  },
  // ...rest unchanged
})
```

### Step 4 — Add type declarations and Tailwind `@source`

```ts
// my-host/src/new-remote.d.ts
declare module "newRemote/feature" {
  import type { FC } from "react"
  export const FeatureComponent: FC
}
```

```css
/* my-host/src/index.css */
@source "../../my-new-remote/src";
```

### Step 5 — Start all three apps and test

```bash
cd my-remote && pnpm dev          # Terminal 1
cd my-new-remote && pnpm dev      # Terminal 2
cd my-host && pnpm dev            # Terminal 3
```

---

## Production Deployment

### 1. Environment-based Remote URLs

Replace hardcoded `localhost` URLs with environment variables:

```ts
// vite.config.ts (host)
remotes: {
  remote: {
    type: "module",
    name: "remote",
    entry: process.env.VITE_REMOTE_URL || "http://localhost:5001/remoteEntry.js",
    entryGlobalName: "remote",
    shareScope: "default",
  },
}
```

```bash
# .env.production
VITE_REMOTE_URL=https://remote.example.com/remoteEntry.js
```

### 2. CORS Configuration

The remote's production server must include the host's origin in `Access-Control-Allow-Origin`.

### 3. Independent Deployments

Each remote can be built and deployed independently. The host fetches `remoteEntry.js` at runtime, so **no host rebuild is needed** when a remote is updated — as long as the exposed API (export names/types) doesn't break.

### 4. Version Pinning

Use `requiredVersion` in `shared` config to enforce compatible versions:

```ts
shared: {
  react: { singleton: true, requiredVersion: "^19.0.0" },
  "react-dom": { singleton: true, requiredVersion: "^19.0.0" },
}
```

### 5. Build Commands

```bash
# Build remote first, then host
cd my-remote && pnpm build
cd my-host && pnpm build

# Preview production builds
cd my-remote && pnpm preview    # Serves on configured port
cd my-host && pnpm preview
```

---

## Configuration Reference

### Remote Config Options

| Option       | Required | Description |
| ------------ | -------- | ----------- |
| `name`       | Yes      | Unique identifier — must match the key used in host's `remotes` |
| `filename`   | Yes      | Output manifest file (usually `remoteEntry.js`) |
| `dts`        | No       | Auto type generation (`false` recommended) |
| `exposes`    | Yes      | Map of public import paths to local file paths |
| `shared`     | Yes      | Shared dependencies with singleton/version config |

### Host Config Options

| Option       | Required | Description |
| ------------ | -------- | ----------- |
| `name`       | Yes      | Unique identifier for the host |
| `remotes`    | Yes      | Map of remote names to their entry configuration |
| `filename`   | No       | Only needed if the host also exposes modules |
| `dts`        | No       | Auto type generation (`false` recommended) |
| `shared`     | Yes      | Must match remote's shared config |

### Remote Entry Config

| Field              | Description |
| ------------------ | ----------- |
| `type`             | Module format — `"module"` for ESM (Vite default) |
| `name`             | Must match the remote's `federation.name` |
| `entry`            | Full URL to the remote's `remoteEntry.js` |
| `entryGlobalName`  | Global variable name for the remote |
| `shareScope`       | Scope for shared dependencies (usually `"default"`) |

### Critical Server Settings (Remote)

| Setting              | Why It's Needed |
| -------------------- | --------------- |
| `server.port`        | Fixed port — host config depends on this exact port |
| `server.strictPort`  | Fail if port is taken, don't silently pick another |
| `server.origin`      | Assets served with absolute URLs so host can resolve them |
| `build.target`       | `"chrome89"` minimum — enables top-level `await` used by federation |

---

## The `.__mf__temp` Directory

This directory is **auto-generated at runtime** by `@module-federation/vite`. It appears when you run the dev server and contains:

- Virtual module wrappers for remote entries
- Runtime initialization scripts
- Type declaration scaffolding (when `dts` is enabled)

**Do not commit this directory.** Add it to `.gitignore`:

```
.__mf__temp
```

---

## Troubleshooting

### "Failed to download types archive from ... @mf-types.zip"

**Cause:** The remote isn't running when the host starts, or `dts` is enabled.
**Fix:** Set `dts: false` in both host and remote federation configs. Use manual `.d.ts` files instead.

### "Can not get effective rootDir"

**Cause:** The `@module-federation/dts-plugin` can't resolve `rootDir` from a project-references-style `tsconfig.json` (`"files": []`).
**Fix:** Set `dts: false` in the federation config. If you still want auto DTS, add `"rootDir": "./src"` to your `tsconfig.app.json`'s `compilerOptions`.

### Remote components render without styles

**Cause:** The host's Tailwind build didn't scan the remote's source files.
**Fix:** Add `@source "../../path-to-remote/src";` in the host's `index.css`.

### Port already in use

**Cause:** Both apps use `strictPort: true`.
**Fix:** Kill the process on the port, or change the port in `vite.config.ts` **and** update the host's `remotes.entry` URL to match.

### Changes in remote not reflected in host

**Cause:** Module Federation caches modules in the browser.
**Fix:** Hard-refresh the host tab (`Ctrl+Shift+R`). For config changes, restart both dev servers.

### "react" singleton mismatch warnings

**Cause:** Host and remote have different React versions.
**Fix:** Ensure both `package.json` files pin the same `react` and `react-dom` versions.

### Remote works standalone but not in host

**Cause:** Missing `server.origin` in the remote's Vite config.
**Fix:** Add `origin: "http://localhost:<PORT>"` to the remote's `server` config so assets use absolute URLs.

### Build fails with "Top-level await is not available"

**Cause:** Build target doesn't support top-level `await`.
**Fix:** Set `build.target: "chrome89"` (or `"esnext"`) in both host and remote configs.

---

## Reference Project Structure

This guide is based on the following working reference implementation:

```
mfa/
├── mfa-host/                    # Host application (port 5000)
│   ├── src/
│   │   ├── App.tsx              # Lazy-loads remote components via React.lazy
│   │   ├── main.tsx             # Standard React entry point
│   │   ├── index.css            # Tailwind + shadcn theme + @source for remote
│   │   ├── remote.d.ts          # Type declarations for remote modules
│   │   ├── components/ui/       # Host's own shadcn/ui components
│   │   └── lib/utils.ts         # cn() utility (clsx + tailwind-merge)
│   ├── vite.config.ts           # Federation host config
│   ├── package.json
│   └── tsconfig.json
│
├── mfa-remote/                  # Remote application (port 5001)
│   ├── src/
│   │   ├── App.tsx              # Standalone app entry
│   │   ├── main.tsx             # Standard React entry point
│   │   ├── index.css            # Tailwind + shadcn theme
│   │   ├── components/
│   │   │   ├── index.ts         # Barrel file — what gets exposed
│   │   │   ├── component-example.tsx
│   │   │   └── ui/              # Remote's own shadcn/ui components
│   │   └── lib/utils.ts
│   ├── vite.config.ts           # Federation remote config
│   ├── package.json
│   └── tsconfig.json
│
├── tools/
│   └── mfx/               # Interactive CLI wizard
│       ├── src/
│       │   ├── cli.ts           # Entry point (commands + error handling)
│       │   ├── types.ts         # TypeScript interfaces
│       │   ├── commands/
│       │   │   ├── init.ts      # Init wizard (full setup)
│       │   │   ├── expose.ts    # Add/update/remove exposed modules
│       │   │   ├── remote.ts    # Add/update/remove remote apps
│       │   │   └── config.ts    # Interactive mfa.config.json editor
│       │   └── utils/
│       │       ├── config.ts    # Config file detection & loading
│       │       ├── detect.ts    # Project detection
│       │       ├── generate.ts  # Config file generators
│       │       ├── log.ts       # Pretty logging
│       │       └── parse.ts     # Parse existing vite.config
│       ├── dist/                # Compiled JS output
│       ├── package.json
│       └── tsconfig.json
│
└── DEVELOPER_GUIDE.md           # This file
```

### Tech Stack (Reference Implementation)

| Technology        | Version  |
| ----------------- | -------- |
| Vite              | 7.2.x   |
| React             | 19.2.x  |
| TypeScript        | 5.9.x   |
| Tailwind CSS      | 4.1.x   |
| shadcn/ui         | 3.x     |
| Module Federation | 1.11.x  |
| pnpm              | latest   |

---

## Quick Reference

| Task                 | Command |
| -------------------- | ------- |
| Install deps         | `pnpm install` |
| Dev (remote — first) | `cd my-remote && pnpm dev` |
| Dev (host — second)  | `cd my-host && pnpm dev` |
| Build                | `pnpm build` |
| Preview              | `pnpm preview` |
| Add shadcn component | `pnpm dlx shadcn@latest add <component>` |
| Lint                 | `pnpm lint` |
| Setup MFA            | `node tools/mfx/dist/cli.js` |

---

## Further Reading

- [`@module-federation/vite` GitHub](https://github.com/module-federation/vite)
- [Module Federation Official Docs](https://module-federation.io/)
- [Tailwind CSS v4 Docs](https://tailwindcss.com/docs)
- [shadcn/ui Docs](https://ui.shadcn.com/)
- [Vite Docs](https://vite.dev/)
