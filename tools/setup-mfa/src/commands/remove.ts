import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { confirm, input } from "@inquirer/prompts";
import type { FileOperation, PackageManager } from "../types.js";
import { detectProject } from "../utils/detect.js";
import { applyAndLog, createBackup, removeBackup } from "../utils/fs.js";
import {
  hint,
  info,
  intro,
  label,
  newline,
  outro,
  step,
  success,
  verbose,
  warn,
} from "../utils/log.js";
import { detectRole, findFederationCall } from "../utils/parse.js";
import { validateDirectory } from "../utils/validators.js";

// ─── Command ───────────────────────────────────────────────────────────────

export async function runRemove(
  opts: { projectDir?: string; yes?: boolean; dryRun?: boolean },
  version: string,
): Promise<void> {
  const yes = opts.yes ?? false;

  intro(version);

  // ── Step 1: Project location ──────────────────────────────────────────

  step(1, "Project location");

  const projectDir =
    opts.projectDir ??
    (await input({
      message: "Where is your project?",
      default: ".",
      validate: validateDirectory,
    }));

  const targetDir = path.resolve(projectDir);
  verbose(`Resolved project directory: ${targetDir}`);
  const project = detectProject(targetDir);

  if (!project) {
    throw new Error(`No package.json found in ${targetDir}`);
  }

  verbose(`Package manager: ${project.packageManager}`);
  const { packageJson, packageManager, viteConfig, srcDir } = project;

  // ── Step 2: Verify federation is present ──────────────────────────────

  step(2, "Analysing project");

  if (!viteConfig) {
    warn("No vite.config found — nothing to remove.");
    return;
  }

  if (!project.hasFederation) {
    warn("Module Federation is not configured in this project. Nothing to do.");
    return;
  }

  const configContent = fs.readFileSync(viteConfig.path, "utf-8");
  const role = detectRole(configContent);
  const fedCall = findFederationCall(configContent);

  newline();
  label("Vite config", path.basename(viteConfig.path));
  label("Role", role ?? "unknown");
  label("Federation call", fedCall ? "found" : "not found");

  // ── Step 3: Confirm ───────────────────────────────────────────────────

  step(3, "Confirm removal");
  newline();

  info("The following changes will be made:");
  newline();

  const operations: FileOperation[] = [];
  const removals: string[] = [];

  // 3a. Remove federation() from vite.config
  if (fedCall) {
    removals.push("Remove federation() plugin from vite.config");

    let newContent = configContent;

    // Remove the federation() call from the plugins array
    // Also remove trailing comma and whitespace
    const before = newContent.slice(0, fedCall.start);
    const after = newContent.slice(fedCall.end);

    // Clean up: remove trailing comma after the federation() call
    const cleanedAfter = after.replace(/^\s*,/, "");
    // Clean up: remove trailing comma before if nothing follows
    const cleanedBefore = before.replace(/,\s*$/, "");

    newContent = cleanedBefore + cleanedAfter;

    // Remove the import line for @module-federation/vite
    const importRegex =
      /^[ \t]*import\s+\{?\s*federation\s*\}?\s+from\s+["']@module-federation\/vite["'];?\s*\n?/m;
    newContent = newContent.replace(importRegex, "");

    operations.push({
      action: "write",
      path: viteConfig.path,
      content: newContent,
      description: "Remove federation plugin from vite config",
    });
  }

  // 3b. Find and mark .d.ts files generated by us
  const dtsGlob = path.join(targetDir, srcDir);
  if (fs.existsSync(dtsGlob)) {
    const dtsFiles = fs
      .readdirSync(dtsGlob)
      .filter((f) => f.endsWith(".d.ts"))
      .map((f) => path.join(dtsGlob, f));

    for (const dtsPath of dtsFiles) {
      try {
        const content = fs.readFileSync(dtsPath, "utf-8");
        if (content.includes("Auto-generated by mfx")) {
          removals.push(`Delete ${path.relative(targetDir, dtsPath)}`);
          operations.push({
            action: "delete",
            path: dtsPath,
            description: `Delete generated type declaration`,
          });
        }
      } catch {
        // Skip unreadable files
      }
    }
  }

  // 3c. Check for config files
  const configFiles = ["mfa.config.json", ".mfarc.json"];
  for (const cfgFile of configFiles) {
    const cfgPath = path.join(targetDir, cfgFile);
    if (fs.existsSync(cfgPath)) {
      const remove =
        yes ||
        (await confirm({
          message: `Delete ${cfgFile}?`,
          default: false,
        }));

      if (remove) {
        removals.push(`Delete ${cfgFile}`);
        operations.push({
          action: "delete",
          path: cfgPath,
          description: `Delete ${cfgFile}`,
        });
      }
    }
  }

  // 3d. Check for .__mf__temp directory
  const mfTempDir = path.join(targetDir, ".__mf__temp");
  const hasMfTemp = fs.existsSync(mfTempDir);
  if (hasMfTemp) {
    removals.push("Delete .__mf__temp/ directory (best-effort, not included in rollback)");
  }

  if (removals.length === 0) {
    info("Nothing found to remove.");
    return;
  }

  // Show summary
  for (const removal of removals) {
    info(`  ${removal}`);
  }

  if (opts.dryRun) {
    newline();
    info("Dry run — no changes were made.");
    hint("Re-run without --dry-run to apply.");
    return;
  }

  newline();
  const proceed =
    yes ||
    (await confirm({
      message: "Proceed with removal?",
      default: false,
    }));

  if (!proceed) {
    info("Cancelled. No changes made.");
    return;
  }

  // ── Apply ──────────────────────────────────────────────────────────────

  // Create backups of all affected files for rollback
  const backups = new Map<string, string>(); // originalPath -> backupPath

  for (const op of operations) {
    if (fs.existsSync(op.path)) {
      const backup = createBackup(op.path);
      if (backup) {
        backups.set(op.path, backup);
      }
    }
  }

  step(4, "Applying changes");
  newline();

  // Log backups
  for (const [original, backup] of backups) {
    info(`Backed up: ${path.basename(original)} → ${path.basename(backup)}`);
  }

  const ok = applyAndLog(operations, targetDir);

  if (!ok) {
    // Offer rollback
    newline();
    warn("Some operations failed during removal.");

    if (backups.size > 0) {
      const shouldRollback =
        yes ||
        (await confirm({
          message: "Rollback all changes? (restore from backups)",
          default: true,
        }));

      if (shouldRollback) {
        let rollbackOk = true;
        for (const [original, backup] of backups) {
          try {
            fs.copyFileSync(backup, original);
            success(`Restored: ${path.basename(original)}`);
          } catch (err) {
            const msg = err instanceof Error ? err.message : String(err);
            warn(`Could not restore ${path.basename(original)}: ${msg}`);
            rollbackOk = false;
          }
        }

        if (rollbackOk) {
          // Rollback succeeded — clean up backup files
          for (const backup of backups.values()) removeBackup(backup);
          success("Rollback complete. No changes were made.");
        } else {
          warn("Partial rollback. Check your project state.");
          hint("Backup files are still available for manual recovery.");
        }
        return;
      }
    }

    throw new Error("Some operations failed. Check the output above.");
  }

  // All operations succeeded — clean up backup files
  for (const backup of backups.values()) removeBackup(backup);

  // Remove .__mf__temp directory (best-effort — not part of atomic rollback)
  if (hasMfTemp && fs.existsSync(mfTempDir)) {
    try {
      fs.rmSync(mfTempDir, { recursive: true, force: true });
      success("Deleted: .__mf__temp/");
    } catch {
      warn("Could not delete .__mf__temp/ — remove it manually.");
    }
  }

  // Offer to uninstall @module-federation/vite
  const allDeps = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies,
  };

  if (allDeps["@module-federation/vite"]) {
    newline();
    const uninstall =
      yes ||
      (await confirm({
        message: "Uninstall @module-federation/vite?",
        default: true,
      }));

    if (uninstall) {
      const uninstallCmd = getUninstallCommand(packageManager, "@module-federation/vite");
      info(`Running: ${uninstallCmd}`);

      try {
        execSync(uninstallCmd, {
          cwd: targetDir,
          stdio: ["inherit", "pipe", "pipe"],
        });
        success("@module-federation/vite uninstalled");
      } catch {
        warn("Uninstall failed — run manually:");
        warn(`  cd ${targetDir} && ${uninstallCmd}`);
      }
    }
  }

  // ── Done ──────────────────────────────────────────────────────────────

  newline();
  outro([
    "Module Federation has been removed.",
    "",
    "You can re-enable it any time by running:",
    "  mfx init",
  ]);
}

// ─── Helpers ───────────────────────────────────────────────────────────────

function getUninstallCommand(pkgManager: PackageManager, pkg: string): string {
  const commands: Record<PackageManager, string> = {
    pnpm: `pnpm remove ${pkg}`,
    yarn: `yarn remove ${pkg}`,
    bun: `bun remove ${pkg}`,
    npm: `npm uninstall ${pkg}`,
  };
  return commands[pkgManager];
}
